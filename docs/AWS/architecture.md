# 電子パーツ管理アプリ AWS サーバーレス移行アーキテクチャ提案

現在の「フロントエンド（SPA）＋バックエンド（Express）＋データベース（SQLite）」という構成に対して、「**ソースコードを修正しない**」「**サーバーレス化**」「**低コスト（月額費用削減）**」「**一定のセキュリティ担保**」という要望を満たすベストプラクティス構成をご提案します。

## 1. 提案するアーキテクチャ構成図

- **フロントエンド**: Amazon S3 + Amazon CloudFront
- **バックエンド API**: Amazon API Gateway（または Lambda Function URLs）+ AWS Lambda
- **データベース**: Amazon EFS（Elastic File System）

## 2. 各コンポーネントの役割と採用理由

### フロントエンド: S3 + CloudFront
ViteでビルドしたVue SPAの静的ファイルをS3バケットに配置し、CloudFront（CDN）経由で配信します。
* **採用理由**: 
  * サーバーレスSPA構成の業界標準であり、爆発的なトラフィックにも耐えられます。
  * CloudFrontの利用料金はデータ転送量に依存しますが、個人や小規模利用であれば**ほぼ無料〜月額数十円**レベルで収まります。
  * S3を直接公開せず、Origin Access Control (OAC) を用いてCloudFrontからのみアクセス可能にすることでセキュアに保てます。

### バックエンド: API Gateway + Lambda + AWS Lambda Web Adapter
ExpressサーバーをAWS Lambda上で稼働させます。
* **採用理由**:
  * ここが**ソースコード無修正の要**です。通常、ExpressをLambdaで動かすにはコードのラップ処理が必要ですが、**[AWS Lambda Web Adapter](https://github.com/awslabs/aws-lambda-web-adapter)** という公式ツールを利用することで、現在のExpressコードを1行も書き換えることなくそのままLambda上で動かすことができます。リクエストは標準的なHTTPリクエストとしてExpressアプリに転送されます。

### データベース: Amazon EFS（Elastic File System）
Lambdaにネットワークファイルシステム (EFS) をマウントし、そこにSQLiteのデータベースファイルを配置します。
* **採用理由**:
  * サーバーレス環境でも**ソース無修正のままデータベース状態を永続化**するための最大のポイントです。Lambdaからは「通常のローカルファイル」としてSQLiteの読み書きが可能になります。
  * ストレージ料金は月額数円〜十数円程度に収まります。

## 3. セキュリティ戦略と追加の要件への対応

ユーザー保護やHTTPS化に関する戦略です。

### 3.1. HTTPS通信と証明書（俺俺証明書は不要）
AWS Certificate Manager (ACM) を利用することで、**正式なパブリックSSL/TLS証明書を完全無料**で自動発行・更新できます。
CloudFront（フロントエンド）およびAPI Gateway（バックエンド）にアタッチすることで、自己署名証明書（俺俺証明書）を使わずに、ブラウザで警告が出ない完全なHTTPS通信が実現可能です。
CloudFrontのデフォルトドメイン（`*.cloudfront.net`）でも、AWS所有の有効な証明書が最初から適用されます。

### 3.2. WAF（Web Application Firewall）
WAFは強力ですが月額固定費（最低$5/月〜）が発生するため、**今回は一旦保留（非適用）**とします。

### 3.3. 認証によるアクセス保護
ソースコードを修正せずにトップ画面をID/パスワードで保護するための戦略です。

* **案: CloudFront Functions を用いた Basic認証**
  * SPAの静的ファイル配信（CloudFront）の手前で、Basic認証をかけます。
  * **料金**: 月間200万リクエストまで無料で、超過しても非常に安価です。ソースコードも一切変更せずにアプリ全体を保護できるため、最も手軽でおすすめです。
  * **ユーザー管理方法 (CloudFront KeyValueStoreの活用)**:
    * CloudFront Functionsから高速に読み取れる **CloudFront KeyValueStore** というデータストアを利用します。ここに「ユーザー名」と「ハッシュ化されたパスワード」のペアを保存します。
    * **ユーザーの追加・削除・変更**: AWSのマネジメントコンソール（Web画面）やAWS CLIから、KeyValueStoreのデータを書き換えるだけで済みます。ソースコードやLambda、CloudFront Functions本体のコードを変更せずに、動的にユーザー管理が可能です。
    * **パスワードのハッシュ化と運用の容易化**: ハッシュ化はMacなどのターミナル・コマンド（例: `echo -n "pass" | shasum -a 256`）で一瞬で行えますが、運用をより簡単にするため、**「ユーザー名とパスワードを入力すると、ハッシュ化してAWS KeyValueStoreに登録・更新してくれる簡単な運用スクリプト」**も合わせてご提供予定です。これによりコマンド一発で安全なユーザー追加が可能になります。

* （参考）Amazon Cognito を使う場合
  * Cognitoユーザープール自体は、月間アクティブユーザー(MAU) 5万名まで**無料**です。
  * ただし、Cognitoログイン画面を挟む構成にするには、バックエンドまたはフロントエンドのコード改修（トークンの検証処理など）が必要になってしまうため、「ソース修正なし」という要件との相性が悪いです。

## 4. コードの二重管理を防ぐ「1ソース複数環境」戦略

ローカル環境用とAWS用のソースコードを分離することなく、完全に**同一のソースコードで管理**するための戦略です。

### 4.1. バックエンド（Express）の共通化
バックエンドは環境変数（`.env`）とDockerファイルによって実行環境を切り替えます。
* **ローカルでの実行**: 今まで通り `node index.js` や `npm run dev` で起動します。
* **AWSでの実行**: アプリコードは全くいじらず、AWS向けの `Dockerfile` を1つリポジトリに追加します。このDockerfile内で「AWS Lambda Web Adapter」を組み合わます。
* **データのパス**: `process.env.DB_PATH` などの環境変数を用いて、ローカルでは `./database.sqlite`、AWS上ではマウントしたEFSのパス `/mnt/efs/database.sqlite` を読み込むようにします（すでに実装されていれば変更不要）。

### 4.2. フロントエンド（Vue/Vite）の共通化
フロントエンドもViteの標準機能である環境モードを活用します。
* **ローカル用**: `.env.development` ファイルにローカルAPIのURL（`http://localhost:3000`など）を定義。
* **AWS用**: `.env.production` にAPI GatewayなどのAWSエンドポイントURLを定義。
* `npm run build` した時点で、AWS用のURLが埋め込まれた静的ファイル（ソースコードを分けずにビルド結果だけ書き換わる）が生成されます。

## 5. 月額コストの試算（概算）

小〜中規模の個人利用を想定した場合（WAFなし構成）：

| サービス | 費用（月額） | 備考 |
| --- | --- | --- |
| **S3** | 約 $0.1 以下 | フロントエンド静的ファイルの保存（数十MB程度）。 |
| **CloudFront** | 約 $0.0 〜 $1 | 毎月1TBの無料枠あり。小規模ならデータ転送料金は無料。 |
| **Lambda** | 約 $0.0 〜 $0.5 | 每月100万回のリクエスト＆計算時間の無料枠あり。 |
| **API Gateway** | 約 $0.0 〜 $1.0 | 最初の100万回までは無料枠あり（HTTP API）。 |
| **EFS** | 約 $0.1 以下 | SQLiteの容量（数MB）ならほぼ0円。 |
| **合計** | **約 $0 〜 $3 / 月** | 極端にアクセスが跳ねない限り、無料枠で**月額数十円〜数百円**で収まります。 |

## 6. まとめ
構築時にクラウド側の設定作業（インフラ構築用コードの作成など）は必要になりますが、アプリケーションのソースコードは今と全く同じものを使い回すことができます。
ローカル開発時はそのまま起動し、デプロイする時は「フロントはViteでビルドしてS3へ」「バックエンドはDockerコンテナにしてLambdaへ」というワークフローを組むことで、無駄な二重管理を回避できます。
